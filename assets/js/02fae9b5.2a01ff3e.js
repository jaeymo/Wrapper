"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[395],{1198:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"type":"mdx","permalink":"/Wrapper/","source":"@site/pages/index.md","title":"Wrapper","description":"Wrapper library. A module that manages the lifecycle of class objects tied to tagged instances.","frontMatter":{},"unlisted":false}');var a=t(4848),l=t(8453);const i={},s="Wrapper",o={},c=[{value:"Why Use Wrapper?",id:"why-use-wrapper",level:2},{value:"Installation",id:"installation",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"Example Usage",id:"example-usage",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"wrapper",children:"Wrapper"})}),"\n",(0,a.jsx)(n.p,{children:"Wrapper library. A module that manages the lifecycle of class objects tied to tagged instances."}),"\n",(0,a.jsxs)(n.p,{children:["Wrapper automates the creation, initialization, and destruction of class objects based on tag instances.\r\nWrapper provides the constructor with a ",(0,a.jsx)(n.a,{href:"https://github.com/Sleitnick/RbxUtil/blob/main/modules/trove/init.luau",children:"Trove"})," object and an optional GUID."]}),"\n",(0,a.jsx)(n.h2,{id:"why-use-wrapper",children:"Why Use Wrapper?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Wrapper makes object-oriented code quicker and cleaner to write."}),"\n",(0,a.jsxs)(n.li,{children:["Wrapper handles the cleanup of the object's metatable and the provided ",(0,a.jsx)(n.a,{href:"https://github.com/Sleitnick/RbxUtil/blob/main/modules/trove/init.luau",children:"Trove"})," object."]}),"\n",(0,a.jsx)(n.li,{children:"There's plenty of customization when it comes to what naming convention Wrapper uses for your class' methods."}),"\n",(0,a.jsx)(n.li,{children:"Generic type-checking does great in this case. Accessing a wrapper object from elsewhere will still provide the class' type-checking."}),"\n",(0,a.jsxs)(n.li,{children:["Promise support for the ",(0,a.jsx)(n.code,{children:"AwaitObject"})," method."]}),"\n",(0,a.jsx)(n.li,{children:"If you are a fanatic about object-oriented programming, this is the module for you! Simply store classes for game objects and apply them via tags."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,a.jsxs)(n.p,{children:["Wrapper is installable via ",(0,a.jsx)(n.a,{href:"https://wally.run/",children:"wally"})," and you can visit the page ",(0,a.jsx)(n.a,{href:"https://wally.run/package/jaeymo/wrapper?version=2.0.3",children:"here"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"dependencies",children:"Dependencies"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/Sleitnick/RbxUtil/blob/main/modules/trove/init.luau",children:"Trove"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/evaera/roblox-lua-promise/blob/master/lib/init.lua",children:"Promise"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/Sleitnick/RbxUtil/blob/main/modules/signal/init.luau",children:"Signal"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/jaeymo/roblox-packages/blob/main/Viewer/init.luau",children:"Viewer"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://github.com/jaeymo/roblox-packages/blob/main/GeneralUtil/init.luau",children:"GeneralUtil"})}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'--!strict\r\n\r\n-- Example class\r\nlocal KillPartClass = {}\r\nKillPartClass.__index = KillPartClass\r\n\r\ntype KillPart = typeof(setmetatable({} :: {\r\n    Part: BasePart,\t\r\n    Trove: any,\r\n    GUID: string\r\n}, KillPartClass))\r\n\r\n-- everytime a part with the "KillPart" tag is added, this runs.\r\nfunction KillPartClass.new(Part: Instance, Trove: any, GUID: string?): KillPart\r\n    local self = setmetatable({}, KillPartClass)\r\n    self.Part = Part :: BasePart\r\n    self.Trove = Trove\r\n    self.GUID = GUID :: string\r\n\r\n    return self\r\nend\r\n\r\nfunction KillPartClass.Init(self: KillPart) -- automatically runs!\r\n    self:WatchTouchedEvent()\r\nend\r\n\r\nfunction KillPartClass.WatchTouchedEvent(self: KillPart)\r\n    self.Trove:Add(self.Part.Touched:Connect(function(Hit: BasePart)\r\n        local Humanoid = Hit.Parent and Hit.Parent:FindFirstChildWhichIsA("Humanoid")\r\n        if not Humanoid then return end\r\n\r\n        Humanoid.Health = 0\r\n    end))\r\nend\r\n\r\nfunction KillPartClass.Destroy(self: KillPart)\r\n    print("This object has been destroyed!") -- the trove and metatable are cleaned externally, no need to do it here.\r\nend\r\n\r\n-- Usage of class\r\nlocal Wrapper = require(path.to.Wrapper)\r\n\r\nlocal KillPartWrapper = Wrapper.new(KillPartClass, "KillPart", {\r\n    Logging = true,\r\n    AutoInit = true, -- AutoInit is true automatically, this redundant but shows what it does nonetheless\r\n    GUID = "KillPart"\r\n})\n'})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var r=t(6540);const a={},l=r.createContext(a);function i(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);