"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[395],{1198:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"type":"mdx","permalink":"/Wrapper/","source":"@site/pages/index.md","title":"Wrapper","description":"Wrapper library. A module that manages the lifecycle of class objects tied to tagged instances.","frontMatter":{},"unlisted":false}');var a=r(4848),s=r(8453);const l={},i="Wrapper",o={},c=[{value:"Why Use Wrapper?",id:"why-use-wrapper",level:2},{value:"Example Usage",id:"example-usage",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"wrapper",children:"Wrapper"})}),"\n",(0,a.jsx)(n.p,{children:"Wrapper library. A module that manages the lifecycle of class objects tied to tagged instances."}),"\n",(0,a.jsxs)(n.p,{children:["Taking a bit of inspiration from ECS systems, Wrapper automates the creation, initialization, and destruction\r\nof tagged class instances. Wrapper provides the constructor with a ",(0,a.jsx)(n.a,{href:"https://github.com/Sleitnick/RbxUtil/blob/main/modules/trove/init.luau",children:"Trove"})," object that is cleaned up on destruction."]}),"\n",(0,a.jsx)(n.h2,{id:"why-use-wrapper",children:"Why Use Wrapper?"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Wrapper makes object-oriented code quicker and cleaner to write."}),"\n",(0,a.jsx)(n.li,{children:"There's plenty of customization when it comes to what naming convention Wrapper uses for your class' methods."}),"\n",(0,a.jsx)(n.li,{children:"Generic type-checking does great in this case. Accessing a wrapper object from elsewhere will still provide the class' type-checking."}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"example-usage",children:"Example Usage"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-lua",children:'--!strict\r\n\r\n-- Example class\r\nlocal KillPartClass = {}\r\nKillPartClass.__index = KillPartClass\r\n\r\ntype KillPart = typeof(setmetatable({} :: {\r\n    Part: BasePart,\t\r\n    Trove: any,\r\n    GUID: string\r\n}, KillPartClass))\r\n\r\nfunction KillPartClass.new(Part: Instance, Trove: any, GUID: string?): KillPart\r\n    local self = setmetatable({}, KillPartClass)\r\n    self.Part = Part :: BasePart\r\n    self.Trove = Trove\r\n    self.GUID = GUID :: string\r\n\r\n    return self\r\nend\r\n\r\nfunction KillPartClass.Init(self: KillPart) -- automatically runs!\r\n    self:WatchTouchedEvent()\r\nend\r\n\r\nfunction KillPartClass.WatchTouchedEvent(self: KillPart)\r\n    self.Trove:Add(self.Part.Touched:Connect(function(Hit: BasePart)\r\n        local Humanoid = Hit.Parent and Hit.Parent:FindFirstChildWhichIsA("Humanoid")\r\n        if not Humanoid then return end\r\n\r\n        Humanoid.Health = 0\r\n    end))\r\nend\r\n\r\nfunction KillPartClass.Destroy(self: KillPart)\r\n    print("This object has been destroyed!") -- the trove and metatable are cleaned externally, no need to do it here.\r\nend\r\n\r\n-- Usage of class\r\nlocal Wrapper = require(path.to.Wrapper)\r\n\r\nlocal KillPartWrapper = Wrapper.new(KillPartClass, "KillPart", {\r\n    Logging = true,\r\n    AutoInit = true, -- AutoInit is true automatically, this redundant but shows what it does nonetheless\r\n    GUID = "KillPart"\r\n})\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>i});var t=r(6540);const a={},s=t.createContext(a);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);